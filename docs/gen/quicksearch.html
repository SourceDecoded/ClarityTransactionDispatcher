<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes ClarityTransactionDispatcher Classes Classes ClarityTransactionDispatcher × Search results Close Documentation generated by JSDoc 3.4.3 on April 17th 2017, 8:14:16 am using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes ClarityTransactionDispatcher Getting Started with Clarity Transaction DispatcherDocumentation In order to use Clarity Transaction Dispatcher there needs to be a MongoDb instance running. Click here to install MongoDb. Once MongoDb is installed start the database as instructed in the link above. Install Clarity Transaction Dispatcher with npm. npm install clarity-transaction-dispatcherThe purpose of the transaction dispatcher is to be the mechanism by which data can flow and notify systems of that data flow. Data can come from devices, database systems, apis, or user input. The dispatcher optimizes for inserts while the systems can optimize for queries. However the dispatcher's inserts can be made atomic and therefore slow because of life cycle methods of systems. It really is up to the developer to decide the speed at which the inserts will be. Fast and eventual consistency or slow and atomic. We will give concrete examples in business where the transaction dispatcher is needed, but first the principle behind the transaction dispatcher is crucial. Video games became more and more complex as the hardware became more advance. This advancement meant games could do more things. With more things came more complexity. There was also a need to turn on and off different affects like shaders, reflections, etc, because of the range of quality of hardware. Game engineers saught for a pattern that would allow them the flexibility they needed as well as the speed. They discovered the &quot;Entity Component System&quot; or &quot;ECS&quot; pattern, which through the years has been refined. The most recent advances have the entities and the components just contain data, and all logic runs on the systems. The systems do not and should not know about eachother. The systems rely on the composition of components to know whether or not to act on the entity. This pattern truly changed the industry. It allowed complexity to be acheived through composition, and simplicity because systems became specialist. They only worried about one thing and did that one thing really well. The main difference between the transaction dispatcher and game engines is that games engine's life-cycle revolved around a 16 millisecond tick. The dispatcher however builds itself around the life-cycle of an entity, specifically, when an entity is added, updated, and removed. With these life-cycles the systems can react to changes in an efficient way. It is slightly more complicated than just three life-cycles, but that is the idea. For a full list of the life-cycles click here. The structure of an entity is as follows. { &quot;_id&quot;: &quot;de34g433ddy22&quot;, &quot;createdDate&quot;: Date, &quot;modifiedDate&quot;: Date, &quot;components&quot;: [ { &quot;type&quot;:&quot;component-type&quot; //... } ] }The entity will only have an &quot;_id&quot;, &quot;createdDate&quot;, &quot;modifiedDate&quot;, and &quot;components&quot; property. The entity's components are just objects of varying properties and the only requirement is that they have a &quot;type&quot; property. The dispatcher doesn't support complex queries because it's expecting the systems to create specialized query databases that then link back, if necessary, to the entity. Think of the dispatcher as a broker of data transfer objects. It's responsibility is storing the current state of an entity and notifying the systems of the changes done to an entity. × Search results Close Documentation generated by JSDoc 3.4.3 on April 17th 2017, 8:14:16 am using the DocStrap template. "},"ClarityTransactionDispatcher.html":{"id":"ClarityTransactionDispatcher.html","title":"Class: ClarityTransactionDispatcher","body":" Documentation Classes ClarityTransactionDispatcher Class: ClarityTransactionDispatcher ClarityTransactionDispatcher Class that organizes systems to respond to data transactions. The dispatcher manages the life-cycle of data entities. They can be added, updated, and removed. The dispatcher is not responsible for anything beyond this. It will notify the systems when any entity has been added, updated, and removed. This allows the dispatcher to remain unopinionated about tasks to run when a certain entity is added, updated, or removed. The idea behind the dispatcher is to handle the complexity of the IoT. There are many systems, devices, and other technologies that need to communicate for a company to run smoothly. We believe that the answer to these needs is a data dispatcher which lets all independent systems know about data changes. new ClarityTransactionDispatcher() Create a Dispatcher. Methods addEntityAsync(entity) Add an Entity to the datastore. The steps the dispatcher takes when saving an entity are. Validate the entity with all systems. All systems have to validate to pass. Save the entity to the datastore. Notify the systems that an entity has been added. Parameters: Name Type Description entity IEntity The entity that you want to save to the datastore. Returns: Type Promise.&lt;Entity&gt; addServiceAsync(name, service) Add a service for systems to use. Services could be HTTP services, or governance that needs to be shared acrossed systems. Parameters: Name Type Description name string The name by which the systems will request the service. service object The service. Returns: Type Promise.&lt;undefined&gt; addSystemAsync(system) Add a system to the dispatcher. The systems are really where the work is done. They listen to the life-cycle of the entity and react based on the composition of components. The dispatcher does the following when adding a system. Adds the system. Invokes initializeAsync if the system hasn't been initialized before. Invokes activatedAsync after initializeAsync is finished. Required System Methods getGuid() getName() Optional System Methods activatedAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) approveEntityRemovalAsync(entity: IEntity) deactivatedAsync() disposedAsync() entityAddedAsync(entity: IEntity) entityRemovedAsync(entity: IEntity) entityRetrievedAsync(entity: IEntity) entityUpdatedAsync(oldEntity: IEntity, updatedEntity: IEntity) logError(error: { type?: string; message?: string; }) logMessage(message: { type?: string; message?: string; }) logWarning(warning: { type?: string; message?: string; }) initializeAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) serviceRemovedAsync(name: string) validateEntityAsync(entity: IEntity) Parameters: Name Type Description system ISystem The system to add. Returns: An undefined Promise. Type Promise approveEntityRemovalAsync(entity) Approves whether an entity can be removed. Systems can deny the ability to remove entities. Parameters: Name Type Description entity object The entity to be removed. deactivateSystemAsync(system) Deactivates a system and removes it from the systems being notified. To activate again use addSystemAsync. Think of this like a pause. The dispatcher calls deactivatedAsync on the system being removed. Parameters: Name Type Description system ISystem The system to be deactivate. Returns: Resolves when the system is deactivated. Type Promise.&lt;undefined&gt; disposeSystemAsync(system) Disposes a system and removes it from the systems being notified. Use when removing systems for good. This allows the system to clean up after itself if needed. The dispatcher calls disposeAsync on the system being removed. Parameters: Name Type Description system ISystem The system to be disposed. Returns: Resolves when the system is disposed. Type Promise.&lt;undefined&gt; getEntitiesAsync(config) Page through entities using the lastId from a previous query. Use null or undefined to begin at the beginning. Parameters: Name Type Description config The configuration of the query. It takes a lastId, pageSize, lastModifiedDate, and a lastCreatedDate. getEntityByIdAsync(entityId) Get an entity by its id. Parameters: Name Type Description entityId string The id of the desired entity. Returns: A Promise resolved with the entity or null. Type Promise.&lt;Entity&gt; getEntityCountAsync() Get count for all entities in collection. getService(name) Get a service by the name given. Parameters: Name Type Description name string The name of the desired service. Returns: Null or the desired service. Type object getSystems() Get all systems. Returns: Type Array.&lt;ISystems&gt; logError(error) Notifies the systems about an error. Parameters: Name Type Description error object The error to be sent to the systems. Returns: Type undefined logMessage(message) Notifies the systems about a message. Parameters: Name Type Description message object The message to be sent to the systems. Returns: Type undefined logWarning(warning) Notifies the systems about a warning. Parameters: Name Type Description warning object The warning to be sent to the systems. Returns: Type undefined removeEntityAsync(entity) Removes the entity to be removed and notifies the systems the entity has been removed. Parameters: Name Type Description entity IEntity The entity to be removed. Returns: Type Promise.&lt;undefined&gt; removeServiceAsync(name) Removes a service by its name. The dispatcher will notify the systems that this service is being removed. Parameters: Name Type Description name string The name of the service to be removed. Returns: Type undefined updateEntityAsync(entity) Update an entity. The dispatcher will perform the following actions when updating. Validate the entity. All interested systems need to validate to pass. Entity's updates are saved. The systems are notified about the update. Parameters: Name Type Description entity object The updated entity. Returns: Resolves when the entity is saved. Type Promise.&lt;undefined&gt; validateEntityAsync() This allows systems to validate the entity being saved. validateSystem(system) Ensures the system has the required methods. Parameters: Name Type Description system ISystem The System to be validated. × Search results Close Documentation generated by JSDoc 3.4.3 on April 17th 2017, 8:14:16 am using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
