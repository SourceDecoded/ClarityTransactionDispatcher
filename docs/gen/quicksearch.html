<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes ClarityTransactionDispatcher Classes Classes ClarityTransactionDispatcher × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 4:08:39 pm using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes ClarityTransactionDispatcher Getting Started with Clarity Transaction DispatcherDocumentation Install Clarity Transaction Dispatcher with npm. npm install ...To be determinedThe purpose of the transaction dispatcher is to be the mechanism by which data can flow and notify systems of that data flow. Data can come from devices, database systems, apis, or user input. We will give concrete examples in business where the transaction dispatcher is needed, but first the principle behind the transaction dispatcher is crucial. Video games became more and more complex as the hardware became more advance. This advancement meant the game could do more things. With more things came more complexity. There was also a need to turn on and off different affects like shaders, reflections, etc, because of the the range of quality of hardware. Game engineers saught for a pattern that would allow them the flexibility they needed as well as the speed. They discovered the &quot;Entity Component System&quot; or &quot;ECS&quot; pattern, which through the years has been refined. The most recent advances have the entities and the components just contain data, and all logic runs on the systems. The systems do not and should not know about eachother. The systems rely on the composition of components to know whether or not to act on the entity. This pattern truly changed the industry. It allowed complexity to be acheived through composition, and simplicity because systems became specialist. They only worried about one thing and did that one thing really well. The main difference between the transaction dispatcher and game engines is that games engine's life-cycle revolved around a 16 millisecond tick. The dispatcher however builds itself around the life-cycle of an entity, specifically, when an entity is added, updated, and removed. With these life-cycles the systems can react to changes in an efficient way. It is slightly more complicated than just three life-cycles, but that is the idea. For a full list of the life-cycles click here. The structure of an entity is as follows. An entity has many components of any type. An entity has content. The entity's components are just objects of varying properties and the only requirement is that they have a &quot;type&quot; property. The content of an entity could be nothing, image binary, or JSON. The entity itself has no important data on it other than its id. It is the container, and that is it. So an entity could have content of an image and have a component with the type &quot;Image&quot;. The image component would have important information on it pertaining to the image like jpg, or png. Of course this component would be maintained by 1 or more systems based on the life-cycle of entity's content and other components. Components and Content can all be validated by systems. This allows systems to ensure integrity with their components. It is important to understand that one system may be validating and governing a component doesn't mean that its the only system to add that component to an entity. For example, there may be to systems interested in a component of type &quot;Image&quot;. They both have ways of uploading new images and deleting them. One system may thumbnail the image and the other may archive them. The key is remember that other systems may not want to govern the component, but they may want to add, update and remove them. × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 4:08:40 pm using the DocStrap template. "},"ClarityTransactionDispatcher.html":{"id":"ClarityTransactionDispatcher.html","title":"Class: ClarityTransactionDispatcher","body":" Documentation Classes ClarityTransactionDispatcher Class: ClarityTransactionDispatcher ClarityTransactionDispatcher Class that organizes systems to respond to data transactions. The dispatcher manages the life-cycle of data entities. They can be added, updated, and removed. The dispatcher is not responsible for anything beyond this. It will notify the systems when any entity has been added, updated, and removed. This allows the dispatcher to remain unopinionated about tasks to run when a certain entity is added, updated, or removed. The idea behind the dispatcher is to handle the complexity of the IoT. There are many systems, devices, and other technologies that need to communicate for a company to run smoothly. We believe that the answer to these needs is a data dispatcher which lets all independent systems know about data changes. The dispatcher will also notify the system when components on the entity have been added updated or removed. This is critical for the systems to fulfill their responsibilities efficiently. new ClarityTransactionDispatcher() Create a Dispatcher. Methods addComponentAsync(entity, component) Adds a component to an entity. The dispatcher does the following when adding a component. Validate the component with all systems. All systems have to validate to pass. Saves the component to the datastore. Notifies the systems that a component has been added. Parameters: Name Type Description entity object The entity of the component being added. component object The component being added. addEntityAsync(stream, components, entityId) Add an Entity to the datastore. The steps the dispatcher takes when saving an entity are. Saves the content of the entity to a datastore. Validate the entity with all systems. All systems have to validate to pass. Save the entity to the datastore. Validate and save the components. Notify the systems that an entity with its components and content have been saved. If any of the steps above fail, it will retract the whole transaction and notify the systems of doing so. Parameters: Name Type Description stream NodeJS.ReadableStream The content of the entity. components Array.&lt;component&gt; An array of components belonging to the entity. entityId string The id that you want to assign to the entity. Returns: Type Promise addServiceAsync(name, service) Add a service for systems to use. Services could be HTTP services, or governance that needs to be shared acrossed systems. Parameters: Name Type Description name string The name by which the systems will request the service. service object The service. Returns: Type Promise.&lt;undefined&gt; addSystemAsync(system) Add a system to the dispatcher. The systems are really where the work is done. They listen to the life-cycle of the entity and react based on the composition of components. The dispatcher does the following when adding a system. Adds the system. Invokes initializeAsync if the systems hasn't been used before, and invokes activatedAsync after initializeAsync is finished. For example an Image Thumbnail System will look to see if the entity has the component of image Required System Methods getGuid() getName() Optional System Methods activatedAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) deactivatedAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) disposeAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) entityAddedAsync(entity: {_id: string}) entityUpdatedAsync(oldEntity: any, newEntity: any) entityRemovedAsync(entity: {_id: string}) entityRetrievedAsync?(entity: { _id: string }); entityContentUpdatedAsync(oldContentId: string, newContentId: string) entityComponentAddedAsync(entity: {_id: string}, component: any) entityComponentUpdatedAsync(entity: {_id: string}, oldComponent: any, newComponent: any) entityComponentRemovedAsync(entity: {_id: string}, component: any) entityComponentRetrievedAsync?(entity: { _id: string }, component: any); initializeAsync(clarityTransactionDispatcher: ClarityTransactionDispatcher) serviceRemovedAsync(name: string, service: any); validateEntityAsync(entity: {_id: string}) validateComponentAsync(component: {_id: string}) validateEntityContentAsync(entity: {_id: string}, oldContentId: string, newContentId: string) approveComponentRemovalAsync(component:{_id: string; entity_id: string}) approveEntityRemovalAsync(entity:{_id: string}) Parameters: Name Type Description system ISystem The system to add. Returns: An undefined Promise. Type Promise approveComponentRemovalAsync(entity) Approves whether a component can be removed. Systems can deny the ability to remove components. Parameters: Name Type Description entity object The entity to be removed. approveEntityRemovalAsync(entity) Approves whether an entity can be removed. Systems can deny the ability to remove entities. Parameters: Name Type Description entity object The entity to be removed. deactivateSystemAsync(system) Deactivates a system and removes it from the systems being notified. To activate again use addSystemAsync. Think of this like a pause. The dispatcher calls deactivatedAsync on the system being removed. Parameters: Name Type Description system ISystem The system to be deactivate. Returns: Resolves when the system is deactivated. Type Promise.&lt;undefined&gt; disposeSystemAsync(system) Disposes a system and removes it from the systems being notified. Use when removing systems for good. This allows the system to clean up after itself if needed. The dispatcher calls disposeAsync on the system being removed. Parameters: Name Type Description system ISystem The system to be disposed. Returns: Resolves when the system is disposed. Type Promise.&lt;undefined&gt; getComponentByIdAsync(componentId) Gets the component by the id provided. Parameters: Name Type Description componentId string The id of the component. Returns: Type Promise.&lt;Array&gt; getComponentCountAsync() Get count for all components in collection. getComponentsByEntityAndTypeAsync(entity, type) Get the Components on the entity provided matching the type provided. Parameters: Name Type Description entity IEntity The entity of the needed components. type string The type of the component needed. getComponentsByEntityAsync(entity) Get the components of an entity by the entity. Parameters: Name Type Description entity IEntity The entity of the components. Returns: Type Promise.&lt;Array&gt; getEntitiesAsync(config) Page through entities using the lastId from a previous query. Use null or undefined to begin at the beginning. Parameters: Name Type Description config The configuration of the query. It takes a lastId, and a pageSize. getEntityByIdAsync(entityId) Get an entity by its id. Parameters: Name Type Description entityId string The id of the desired entity. Returns: A Promise resolved with the entity or null. Type Promise.&lt;Entity&gt; getEntityContentStreamByContentIdAsync(contentId) Get a stream of the content of the entity by its id. Parameters: Name Type Description contentId string The id of the content needed.. Returns: Node read stream. Type NodeJS.ReadableStream getEntityContentStreamByEntityAsync(entity) Get a stream of the content of the entity. Parameters: Name Type Description entity IEntity The entity of the content needed. Returns: Node read stream. Type Promise.&lt;stream&gt; getEntityCountAsync() Get count for all entities in collection. getService(name) Get a service by the name given. Parameters: Name Type Description name string The name of the desired service. Returns: Null or the desired service. Type object logError(error) Notifies the systems about an error. Parameters: Name Type Description error object The error to be sent to the systems. Returns: Type undefined logMessage(message) Notifies the systems about an error. Parameters: Name Type Description message object The message to be sent to the systems. Returns: Type undefined logWarning(warning) Notifies the systems about a warning. Parameters: Name Type Description warning object The warning to be sent to the systems. Returns: Type undefined removeComponentAsync(component) Remove a component from an entity. Parameters: Name Type Description component object The component to be removed. Returns: Type Promise.&lt;undefined&gt; removeEntityAsync(entity) Removes an entity, and its associated content. The dispatcher does the following to remove an entity. Removes all of the components on the entity notifying the systems that the components have been removed. Removes the content and notifies the systems. Removes the entity to be removed and notifies the systems the entity has been removed. Parameters: Name Type Description entity IEntity The entity to be removed. Returns: Type Promise.&lt;undefined&gt; removeEntityContentAsync(entity) Removes the content of an entity. Parameters: Name Type Description entity IEntity The entity of the content to be removed. removeServiceAsync(name) Removes a service by its name. The dispatcher will notify the systems that this service is being removed. Parameters: Name Type Description name string The name of the service to be removed. Returns: Type undefined updateComponentAsync(component) Update a component. The dispatcher will perform the following actions when updating the component of an entity. Validate the component. All interested systems need to validate to pass. Save the component to the datastore. Notify the systems that the component was updated. Parameters: Name Type Description component object The component to be updated. updateEntityAsync(entity) Updated an entity. The dispatcher will perform the following actions when updating. This really shouldn't be used much. The entity is really just a container for the content_id and the components. Validate the entity. All interested systems need to validate to pass. Entity's updates are saved. The systems are notified about the update. Parameters: Name Type Description entity object The updated entity. Returns: Resolves when the entity is saved. Type Promise.&lt;undefined&gt; updateEntityContentByStreamAsync(entity, stream) Update an entity's content. The dispatcher will perform the following actions when updated the content of an entity. Save the new content to the datastore. Validate the new content. All interested systems need to validate to pass. The entity.content_id is updated and saved. Notify the systems of the updated content. The old content is now removed from the datastore. Parameters: Name Type Description entity object The entity whos content is to be update. stream NodeJS.WritableStream The stream to save to the content of the entity. Returns: Type Promise.&lt;undefined&gt; validateComponentAsync() This allows systems to validate the component being saved. validateEntityAsync() This allows systems to validate the entity being saved. validateEntityContentAsync(entity, newContentId) This allows the systems to validate content before its accepted. The dispatcher saves it to a temporary location so systems can validate it independently. The content could be an extremely large file so we don't want to hold it in memory. Parameters: Name Type Description entity IEntity The entity the content belongs to. newContentId string The id of the new content. validateSystem(system) Ensures the system has the required methods. Parameters: Name Type Description system ISystem The System to be validated. × Search results Close Documentation generated by JSDoc 3.4.3 on March 21st 2017, 4:08:40 pm using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
